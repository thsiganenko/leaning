/* Треугольник в цикле.
 *
 * Напишите функцию, которая принимает на вход количество строк (целое число)
 * и символ, и выводит в консоль треугольник вида:
 * #
 * ##
 * ###
 * ####
 * #####
 * ######
 * #######
 */

function triangle(count, char) {
    char = char || '#';
    for (var line = char; line.length <= count; line += char) {
        console.log(line);
    }
}

/* FizzBuzz 
 *
 * Напишите функцию, которая выводит через console.log все цифры от 1 до 100,
 * с двумя исключениями. Для чисел, нацело делящихся на 3, она должна выводить
 * ‘Fizz’, а для чисел, делящихся на 5 (но не на 3) – ‘Buzz’.
 *
 * Исправьте её так, чтобы она выводила «FizzBuzz» для всех чисел, которые
 * делятся и на 3 и на 5.
 */

function fizzBuzz () {
    for (var n = 1; n <= 100; n++) {
        var output = "";
        if (n % 3 === 0)
            output += "Fizz";
        if (n % 5 === 0)
            output += "Buzz";
        console.log(output || n);
    }
}

/* Шахматная доска
 *
 *
 * Напишите программу, создающую строку, содержащую решётку 8х8, в которой
 * линии разделяются символами новой строки. На каждой позиции либо пробел,
 * либо #. В результате должна получиться шахматная доска.
 *
 * # # # #
 *  # # # #
 * # # # #
 *  # # # #
 * # # # #
 *  # # # #
 * # # # #
 *  # # # #
 */

function chessBoard (size) {
    size = size || 8;
    var board = "";
        for (var y = 0; y < size; y++) {
            for (var x = 0; x < size; x++) {
                if ((x + y) % 2 == 0)
                    board += " ";
                else
                    board += "#";
            }
            board += "\n";
        }

    console.log(board);
}

/* Нахождение минимума
 *
 * Напишите функцию min, принимающую два аргумента, и возвращающую минимальный
 * из них.
 */

function min(a, b) {
    if (a > b)
        return b;
    return a;
}


/* Определить четность числа с помощью рекурсивной функции
 *
 * У любого числа N чётность такая же, как у N-2.
 * Напишите рекурсивную функцию isEven согласно этим правилам. Она должна
 * принимать число и возвращать булево значение.
 */


function isEven (x) {
    if (x < 0) x *= -1;
    if (x == 0) return true;
    if (x == 1) return false;
    return isEven(x-2);
}

/* Считаем бобы.
 *
 * Символ номер N строки можно получить, добавив к ней .charAt(N) (
 * “строчка”.charAt(5) ) – схожим образом с получением длины строки при помощи
 * .length. Возвращаемое значение будет строковым, состоящим из одного
 * символа (к примеру, “к”). У первого символа строки позиция 0, что
 * означает, что у последнего символа позиция будет string.length – 1.
 * Другими словами, у строки из двух символов длина 2, а позиции её символов
 * будут 0 и 1.  -> Напишите функцию countBs, которая принимает строку в
 * качестве аргумента, и возвращает количество символов “B”, содержащихся в
 * строке.  -> Затем напишите функцию countChar, которая работает примерно
 * как countBs, только принимает второй параметр — символ, который мы будем
 * искать в строке (вместо того, чтобы просто считать количество символов
 * “B”). Для этого переделайте функцию countBs.
 */

function countChar(string, ch) {
    var counted = 0;
    for (var i = 0, len = string.length; i < len; i++) {
        if (string.charAt(i) == ch) {
                counted += 1;
            }
    }
    return counted;
}

function countBs(string) {
    return countChar(string, "B");
}

/* Сумма диапазона
 *
 * Напишите функцию range, принимающую два аргумента, начало и конец диапазона,
 * и возвращающую массив, который содержит все числа из него, включая начальное
 * и конечное.
 * Затем напишите функцию sum, принимающую массив чисел и возвращающую их сумму.
 * В качестве бонуса дополните функцию range, чтобы она могла принимать
 * необязательный третий аргумент – шаг для построения массива. Если он не
 * задан, шаг равен единице. Вызов функции range(1, 10, 2) должен будет вернуть
 * [1, 3, 5, 7, 9]. Убедитесь, что она работает с отрицательным шагом так, что
 * вызов range(5, 2, -1) возвращает [5, 4, 3, 2].
 */

function range(start, end, step) {
    var array = [];
    step = step || 1;
    if (step > 0) {
        for (var i = start; i <= end; i += step) {
              array.push(i);
        }
    } else {
        for (var i = start; i >= end; i += step) {
              array.push(i);
        }
    }
    return array;
}

function sum(array) {
    var total = 0;
    for (var i = 0, len = array.length; i < len; i++) {
        total += array[i];
    }
    return total;
}

/* Обращаем вспять массив
 *
 * У массивов есть метод reverse, меняющий порядок элементов в массиве на
 * обратный. В качестве упражнения напишите две функции, reverseArray и
 * reverseArrayInPlace. Первая получает массив как аргумент и выдаёт новый
 * массив, с обратным порядком элементов. Вторая работает как оригинальный метод
 * reverse – она меняет порядок элементов на обратный в том массиве, который был
 * ей передан в качестве аргумента. Не используйте стандартный метод reverse.
 */

function reverseArray(array) {
	var new_array = []
	for (var i = array.length; i > 0; i--) {
        new_array.push(array[i-1]);
    }
	return new_array;
}

function reverseArrayInPlace(array) {
	var temp;
	var j = array.length, k = 0;
	for (var i = Math.floor(j/2); i > 0; i--) {
		temp = array[k];
		array[k] = array[j-1];
		array[j-1] = temp;
		k++; j--;
	}
	return array;
}

function reverseArrayInPlaceAlt(source) {
	for (var i = 0; i < source.length; i++) {
		source.splice(i, 0, source.pop());
	};
}
